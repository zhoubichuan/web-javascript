---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 十.Function

## 模拟 new 的实现

```js
function Animal(){
    this.type=type
    return {name:'123'}
}
Animal.prototype.say=function(){
    console.log('say')
}
function mockNew(){
    let Constructor=[].shift.call(arguments)o
    let obj={}
    obj.__proto__=Constructor.prototype
    let r=Constructor.apply(obj,arguments)
    return r instanceof Object?r:obj
}
let animal=mockNew(Animal,'哺乳类')
```

`new`的底层实现

```js
function _new(fn, ...args) {
  let obj = Object.create(fn.prototype)
  fn.call(obj)
  return obj
}
```

## 函数柯里化

柯里化函数思想：一个 js 预处理的思想-->利用函数执行可以形成一个不销毁的私有作用域的原理，把需要预先处理的内容都存储在这个不销毁的作用域中，并且返回一个小函数，以后我们执行的都是小函数，在小函数宏把之前预先存储的值进行相关的操作

函数柯里化：是指将多变量函数拆解为单变量的多个函数的依次调用，可以从高元函数动态的生成批量的低元的函数。

```js
function add(x, y) {
  return x + y
}
add(1, 2)
```

柯里化函数 add

```js
function curryAdd(x){
    retrun function(y){
        return x+y
    }
}
add(1)(2)
```

```js
//-->柯里化函数思想：一个js预处理的思想-->利用函数执行可以形成一个不销毁的私有作用域的原理，把需要预先处理的内容都存储在这个不销毁的作用域中，并且返回一个小函数，以后我们执行的都是小函数，在小函数宏把之前预先存储的值进行相关的操作

function _bind(callback, context) {
  context = contenx || window
  return function () {
    callback.call(context)
  }
}
var obj = { name: "珠峰培训" }
function fn() {
  console.log(this)
}
setTimeout(_bind(fn, obj), 0)
setTimeout(fn.bind(obj), 0)

//给元素的某一个行为绑定方法，当行为触发的时候，执行的对应的方法，此时方法中的this是当前元素本身，而且了浏览器还会给当前的方法默认的传递一个参数值，MouseEvent(鼠标事件对象)
document.body.onclick = function () {
  console.log(this)
}
document.body.onclick = function (num1, num2) {
  console.log(this, num1, num2) //body,MouseEvent，undefined
}
document.body.onclick = function () {
  console.log(this)
}.bind(obj, 100, 200)
//-->除了预先处理了this和需要手动传递的参数值以外，把浏览器默认给传递的鼠标事件对象也进行了预先处理了
```

### call

```js
var ary = [12, 23, 34]
//ary.slice -->ary这个实列通过原型链的查找机制找到Array.prototype上的slice方法
//ary.slice()-->让找到的slice方法执行，在执行slice方法的过程中，才把ary数组进行了截取

// Function.prototype.call = function(){

// }
var obj = { name: "123" }
function fn() {
  console.log(this)
}
fn() //-->this-->window
fn.call(obj)

Function.prototype.myCall = function (context) {
  //1、将fn中的this变成obj
  eval(this.toString().replace("this", context))
  //2、让fn方法执行
}
fn.myCall(obj)

/* 思考题 */
function fn1() {
  console.log(1)
}
function fn2() {
  console.log(2)
}
fn1.call(fn2) //-->1

fn1.call.call(fn2) //fn1.call 首先通过原型链找到Function.prototype上的call方法，然后再让call方法通过原型找到Function原型上的call（因为call本身的值也是一个函数，所以可以找到Function.prototype）,在第二次找到call的时候让方法执行，方法中的this

fn.call() //-->window 严格模式下window
fn.call(null) //-->window 严格模式下null
fn.call(undefined) //-->window 严格模式下undefined

//apply和call方法的作用是一模一样的，都是用来改变方法的this关键字并且把方法执行：而且在严格模式下和非严格模式下对于第一个参数是null/underfined这种情况的规律也是一样的
fn.call(obj, 100, 200)
fn.apply(obj, [100, 200]) //-->call在给fn传递参数的时候，是一个个的传递值得，而apply不是一个个传，而是把要给fn传递的参数统一的放在一个数组中进行操作--》但是也相当于一个个的给fn形参赋值

//bind:这个方法在ie6-8下不兼容-->和call/apply类似都是用来改变this关键字的

//预处理：事先把fn的this改变为我们想要的结果，并且把对应的参数值也准备好，以后要用到了，直接的执行即可
fn.call(obj, 1, 2) //改变this和执行fn函数是一起都完成了
var tempFn = fn.bind(obj, 1, 2) //只是改变了fn中的this为obj，并且给fn传递了两个参数值1、2，但是此时并没有把fn这个函数执行,执行bind会有一个返回值，这个返回值tempFnv就是我们把fn的this改变后的那个结果
tempFn()

/* 获取数组的最大值 */
var ary = [12, 32, 11, 3, 43, 5, 12, 23, 43]
//1
var sum = ary.sort(function (a, b) {
  return a - b
})
var min = sum[0]
var max = sum[sum.length - 1]
//2
var min = ary[0]
var max = ary[0]
for (var i = 1; i < ary.length; i++) {
  ary[i] < min ? (min = ary[i]) : null
  ary[i] > max ? (max = ary[i]) : null
}
//3
var min = eval("Math.min(" + ary.toString() + ")")
var max = eval("Math.max(" + ary.toString() + ")")

//4
var max = Math.max.apply(null, ary)
var min = Math.min.apply(null, ary)
//6-->括号表达式
function fn1() {
  console.log(1)
}
function fn2() {
  console.log(2)
}
;(fn1, fn2)()(
  //只有fn2执行了 （x1,x2,x3）括号表达式，一个括号中出现多项内容，中间用“，”隔开，但是我们最后获取到的结果只有最后一项
  fn2,
  obj.fn
)()(
  //执行的是obj.fn，但是执行的时候里面的this变为了window而不是obj
  obj.fn
)() //this还是obj

/* 获取平均数 */
function avgFn() {
  //将类数组转换为数组
  // var ary = []
  // for(var i = 0;i<arguments.length;i++){
  //   ary[ary.length] = arguments[i]
  // }
  // ary.sort(function(a,b){
  //   return a-b
  // })
  var ary = Array.prototype.slice.call(arguments)
  //或者ary = [].slice.apply(arguments)
}
ary.pop()
ary.unshift()
return (eval(ary.join("+")) / ary.length).toFixed(2)

//2种方法
function avgFn() {
  Array.prototype.sort.call(arguments, function (a, b) {
    return a - b
  })
  ;[].shift.call(arguments)
  ;[].pop.call(arguments)
  return eval([].join.call(arguments, "+") / arguments.length).toFixed(2)
}
```

### callback

```js
//-->forEach：用来遍历数组中的每一项
//1、数组中有几项，那么我们传递进去的匿名回调函数就需要执行几次
//2、每一次执行匿名函数的时候，还给其传递了三个参数值:数组中的当前项item，当前项的索引index，原始的数组input
//3、理论上我们的方法是没哟返回值的，仅仅是遍历数组中的每一项，不对原来的数组进行修改，但是我们可以通过数组的索引来修改原来的数组
var ary = [12, 3, 4, 5, 6]
ary.forEach(function () {
  console.log("ok")
})
var res = ary.forEach(function (item, index, input) {
  input[index] = item * 10
})

//map方法
//1、map的回调函数中支持return返回值，return是啥，相当于
//2、不管是forEach还是map都在ie6、7、8下不兼容
var ary = [12, 3, 4, 67, 8]
var res = ary.map(function (item, index, input) {
  return item * 10
})
//匿名回调函数的this是window
var obj = { name: 10 }
var ary = [12, 3, 4, 67, 8]
var res = ary.map(
  function (item, index, input) {
    return this
  }.call(obj)
) //undefined
var res = ary.map(
  function (item, index, input) {
    return this
  }.bind(obj)
)

//不管是forEach还是map都支持两个参数，第二个参数是匿名函数的this
var res = ary.map(function (item, index, input) {
  return this
}, obj)
Array.prototype.myForEach = function (callback, context) {}
```

### this

```js
//我们在js中主要研究的都是函数中的this
//js中的this代表的是当前行为执行的主体，js中的context代表的是当前行为执行的环境（区域）
//this是谁和函数在哪定义的和在哪执行的都没有任何关系，如何区分this呢
//1、函数执行，首先看函数名前面是否有"."，有的话，"."前面是谁this就是谁，没有的话this就是windwo
function fn() {
  console.log(this)
}
var obj = { fn: fn }
f() //this -->window
obj.fn() //this-->obj

function sum() {
  //this-->windwo
  fn()
}
sum() //this-->window

var oo = {
  sum: function () {
    //this-->oo
    fn()
  },
}
oo.sum() //this-->window

//2、自执行函数中的this永远都是window
//3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素
document.getElementById("div").onclick = fn //fn-->this -->div
document.getElementById("div").onclick = function () {
  //this-->div
  fn() //this-->window
}

/* 练习题 */
var num = 20
var obj = {
  num: 30,
  fn: (function (num) {
    this.num *= 3
    num += 45
    var num = 45
    return function () {
      this.num *= 4
      num += 20
      console.log(num)
    }
  })(num), //把全局变量num的值20赋值给自执行函数的形参，而不是obj的30，如果想是obj下的30,我们要写成obj.num
}
var fn = obj.fn

fn() //-->65
obj.fn() //-->85
console.log(window.num, obj.num) //-->240,120
//window
!(function () {})()
```

## 全局变量

```js
//在全局作用域中，带var和不带var的关系
//区别：带var的可以进行预解释，所以在赋值的前面执行不会报错；不带var的是不能进行预解释，在前面执行会报错
console.log(num) //-->undefined
var num = 12

console.log(num2) //VM229:1 Uncaught ReferenceError: num2 is not defined
num2 = 12

//关系：num2 = 12-->相当于给window增加了一个叫做num2的属性名，属性值是12
//var num = 12 -->首先它相当于给全局作用域增加了一个全局变量num,但是不仅如此，它也相当于给windwo增加了一个属性名num,属性值是12
var num = 12
console.log(num)

num2 = 12
console.log(num2)

//私有作用域中出现一个变量不是私有的，则往上级作用域查找，如果上级作用域没有则继续向上查找，一直找到window为止，如果window下也没有
//-->我们是获取值：console.log(total) -->报错了
//-->我们是设置值：total = 100 -->相当于给window增加了一个属性名total，属性值是100
function fn() {
  // console.log(total)
  total = 100
}
fn()
console.log(total)
//js中如果不进行任何特殊处理的情况下，上面的代码报错，下面的代码都不在执行
```

### 类型

```js
//基本数据类型和引用数据类型的区别
var num1 = 12
var num2 = num1
num2++
console.log(num1) //12
var obj1 = { age: "12" }
var obj2 = obj1
obj2.age = 13
console.log(obj1.age) //13
//基本数据类型的值没有变，引用数据类型的值变了
//基本数据类型和引用数据类型的本质区别
//基本数据类型是把值直接给变量，接下来在操作的过程中，直接拿这个值操作的，可能两个变量存储一样的值，但是你的是你的，我的是我的，之间没有关系，其中一个改变，另一个没有任何影响
//引用数据类型：
//定义一个变量
//开辟一个新的空间，然后把属性名和属性值保存在这个空间中，并且有一个空间地址
//把空间的地址给了这个变量，变量并没有存储这个数值，而是存储的是对这个空间引用地址
//接下来我们把这个地址，又告诉另外一个变量，另外一个变量存储的也是这个地址，此时两个变量操作的是同一个空间
//其中一个改变了空间的内容，另外一个也跟着改变了

//js中检查数据类型的方式
//typeof运算符    -->返回值：是一个字符串，包含了数据类型字符"number","string","object","boolean","undefined","function"
//typeof null 的结果是"object"
//typeof的局限性：不能细分object下细分的类型
var num2 = 12
console.log(typeof num2)

/* 试题 */
console.log(typeof typeof typeof typeof []) //"string"
//instanceof运算符
//constructor
//Object.prototype.toString.call()
```

### 预解释

```js
//基本数据类型：String Number 按值操作

//引用数据类型：Object和Function -->地址操作

//->函数：1、创建一个函数 2、执行一个函数
function sum() {
  var total = null
  total = 1 + 1
  console.log(total)
}
//1、当浏览器加载页面的时候首先会提供一个供js代码执行的环境->全局作用域的环境 首先开辟一个新的内存空间，浏览器为其分配一个16进制的地址，我们假设地址为：xxxfff000
//2、把函数体中的js代码当做"字符串"存储到内存空间中
//3、再把这个地址赋值给当前的函数名sum ->sum =xxxfff000
sum //->后面不加小括号，代表的就是当前函数本身
sum() //后面加小括号，代表的是执行当前函数
//函数执行的目的：把函数之前存储的那些字符串变成js代码，然后再让js代码从上到下依次执行

//函数执行的步骤：
//1、函数执行的时候，首先会提供一个供函数体中代码执行的环境 ->'私有作用域'
//2、把函数体重的代码字符从上到下执行

//我们把函数执行的时候形成的这种保护机制叫做闭包

//return 函数的一个出口返回的是其值

//arguments

//实名函数：起了名字的函数就是实名函数
//匿名函数：没有起名字的函数就是匿名函数

//js中常用到的匿名函数有两种
//1、只执行函数：定义函数和函数执行一起完成了
//+ - ! ~ ; ()
//2、函数表达式：把函数定义的部分当做一个值赋值给一个变量或者元素的某一个行为
//oDiv.onclick=function(){}

//函数在整个js中是最复杂也是最重要的知识
/* 
1、一个函数存在了多面性：
普通函数：它本身就是一个普通的函数，执行的时候形成私有的作用域（闭包）形参赋值，预解释，代码执行，执行完成后栈内存销毁/不销毁
类：它有自己的实列，也有一个叫做prototype属性是自己的原型，他的实列都可以指向自己的原型
普通对象：和var obj = {}中的obj一样，就是一个普通的对象，它作为对象可以有一些自己的私有属性，也可以通过__proto__找到Function.prototype
这三者之间没有必然的关系
*/
function Fn() {
  this.x = 100
}
Fn.prototype.getX = function () {
  console.log(this.x)
}
Fn.aaa = 1000
var f = new Fn()
f.num-- > undefined
f.aaa-- > undefined
var res = Fn()
res-- > undefined
Fn.aaa-- > 1000
```

```js
/* js中的数据类型 */
//1、基本数据类型：number、strting、boolean、null、undefined
//2、引用数据类型：object：{}、[]、/^$/、Date   function
var num = 12
var obj = { name: "珠峰培训", age: 7 }
function fn() {
  console.log("......")
}
console.log(fn) //-->把整个函数的定义部分（函数本身）在控制台输出
console.log(fn()) //-->把当前函数执行的返回结果（return后面写的是啥，返回值就是啥），如果没有return,默认返回值就是undefined

//1、当浏览器加载HTML页面的时候，首先会提供一个供全局JS代码执行的环境 -->全局作用域（global/window）

//2、预解释（变量提升）
// 在当前的作用域中，js代码执行之前，浏览器首先会默认的把所有带var 和function的进行提前的声明或者定义
//1)理解声明和定义
//var num = 12
//声明（declare）：var num -->告诉浏览器在全局作用域中有一个num的变量了-->如果一个变量只是声明但是没有赋值，undefined
//定义（defined）：num = 12 -->给我们的变量进行赋值

//2）对于带var 和 function 关键字的在预解释的时候操作还是不一样的
//var -->在预解释的时候只是提前声明
//function -->在预解释的时候提前的声明+定义都完成了

//3)预解释只发生在当前作用域下，例如：开始只对window下的进行预解释，只有函数执行的时候才会对函数中的进行预解释
var num = 12
var obj = { name: "珠峰培训", age: 7 }
function fn(num1, num2) {
  var total = num1 + num2
  console.log(total)
}
console.log(fn)
console.log(fn())

//3、js中内存的分类
//栈内存：用来提供一个供js代码执行的环境 -->作用域（全局作用域/私有的作用域）
//堆内存：用来存储引用数据类型的值 -->对象存储的是属性名和属性值，函数存储的是代码字符串
console.log(num) //undefined
var num = 12
var obj = { name: "珠峰培训", age: 7 }
fn(100, 200) //可以执行，因为声明和定义都完成了
function fn(num1, num2) {
  var total = num1 + num2
  console.log(total)
}
console.log(fn)
console.log(fn())

/* 预解释是一种毫无节操的机制 */
//in：""num" in window 判断num是否为window这个对象的是一个属性，是的话返回true
//1、预解释的时候不管你的条件是否成立，都要把带var 的进行提前声明
// window的预解释：var num -->window.num
if (!("num" in windwo)) {
  var num = 12
}
console.log(num) //undefined

//2、预解释的时候只预解释“=”左边的，右边的是值，不参与预解释
fn() //-->ok
function fn() {
  console.log("ok")
}
fn() //ok

//匿名函数之函数表达式：把函数定义的部分当做一个值赋值给我们的变量/元素的某一个事件
fn() //-->fn is not a function
var fn = (function () {
  console.log("ok")
})(
  // 3、执行函数定义的那个function在全局作用域下不进行预解释，当代码执行到这个位置的时候定义和执行一起完成了
  // 自执行函数：定义和执行一起完成了
  function (num) {}
)(100)
~(function (num) {})(100) + (function (num) {})(100)
;-(function (num) {})(100)
!(function (num) {})(100)

//4、函数体中return下面的代码虽然不再执行，但是需要进行预解释;return后面跟着的都是我们返回的值，所以不进行预解释
function fn() {
  // 预解释:var num
  console.log(num) //-->undefined
  return function () {}
  var num = 100
}
fn()

// 5、在预解释的时候，如果名字已经声明过了，不需要重写再声明，但是需要重写的赋值
//在js中如果变量的名字和函数的名字重复了，也算冲突
//预解释：var fn；window。fn；fn=xxxfff000；window.fn = xxxfff000

var fn = 13
function fn() {
  console.log("ok")
}

//window预解释
//声明+定义 fn = xxxfff111
//声明 var fn；（不需要重新声明）
//声明（不重复进行）+定义 fn = xxxfff222
fn() //-->2
function fn() {
  console.log(1)
}
fn() //-->2
var fn = 10 //fn = 10
fn() //10() -->fn is not a function
function fn() {
  console.log(2)
}
fn()
```

#### 作用域链

## 1、如何区分私有变量和全局变量

### 在全局作用域下声明（预解释的时候）的变量是全局变量

### 在 私有作用域中声明的变量 和 函数的形参 都是私有的变量

#### 在私有作用域中，我们代码执行的时候遇到了一个变量，首先我们需要确定它是否为私有的变量，如果是私有变量，那么和外面的没有任何的关系；如果不是私有的，则网当前作用域的上级作用域进行查到，如果上级作用域也没有则继续查找，一直找到 window 为止...(作用域链)

## 2、当函数执行的时候（直接目的：让函数体重的代码执行），首先会形成一个新的私有的作用域，然后按照如下的步骤执行：

### 如果有形参，先给形参赋值

### 进行私有作用域中的预解释

### 私有作用域中的代码从上往下执行

#### 函数形成了一个新的私有的作用域保护了里面的私有变量不受外界的干扰（外面修改不了私有的，私有的也修改不了外面的）-->闭包

- 首选代码从上往下预解释声明 total，然后从上往下执行代码，total 此时没有被赋值所有为 undefined

```
console.log(total); //-->undefined
var total = 0;
```

- 同理私有作用域下面也是，声明了 total 但是没有赋值，结果为 undefiend

```
var total = 0;
function fn(num1, num2) {
  console.log(total); //undefined
  var total = num1 + num2;
  console.log(total); //-->300
}
fn(100, 200);
console.log(total); //-->0
```

- 私有作用域下面没有 total，顺着作用域链向上查找，找到全局的 total=0

```
console.log(total); //-->undefined
var total = 0;
function fn(num1, num2) {
  console.log(total); //total 不是私有的找全局下的 total 找这里出现的所有的 total 其实应该是全局的-->0
  total = num1 + num2;
  console.log(total); //-->300
}
fn(100, 200);
console.log(total); //-->300
```

[面试题](./面试题.js)

## 3、如何查找上级作用域

### 看当前函数是在哪个作用域下定义的，那么他的上级作用域就是谁，和函数在哪执行的没有任何关系

```
var num = 12;
function fn() {
  var num = 120;
  return function() {
    console.log(num);
  };
}
var f = fn();
f();
~(function() {
  var num = 1200;
  f();
})();
```

```js
/* 关于内存的释放和作用域销毁的研究 */
//堆内存
//对象数据类型或者函数数据类型在定义的时候首先会开辟一个堆内存，堆内存有一个引用的弟子，如果外面有变量等知道了这个地址，我们就说这个内存被占用了就不能销毁了
var obj1 = { name: "张三" }
var obj2 = obj1
//我们想要让堆内存释放/销毁，只需要把所有引用它的变量赋值为null即可，如果当前的堆内存没有任何东西被占用，那么浏览器会在空闲的时候把他销毁...
obj1 = null
obj2 = null

//栈内存
// 1）全局作用域
//只有当页面关闭的时候全局作用域才会销毁

// 2）私有作用域（只有函数执行的时候会产生私有作用域）
// 一般情况下，函数执行会形成一个新的私有作用域，当私有作用域中代码执行完成后，我们当前作用域都会主动的进行释放和销毁
//但是还是存在特殊的情况：
// 当前私有作用域中的部分内存被作用域以外的东西占用了，那么当前的这个作用域就不能销毁了
//a、函数执行返回了一个引用数据类型的值，并且在函数的外面被一个其他的东西给接受了，这种情况下一般形成的私有作用域都不会销毁
function fn() {
  var num = 100
  return function () {}
}
var f = fn()

//在一个私有的作用域中给DOM元素的事件绑定方法，一般情况下我们的私有作用域都不销毁
var oDiv = document.getElementById("div")
~(function () {
  oDiv.onclick = function () {}
})() //当前的自执行函数形成的这个私有的作用域也不销毁

//下述情况属于不立即销毁，-->fn返回的函数没有被其他的东西占用，但是还需要执行一次，所以暂时不销毁，当返回的值执行完成以后，浏览器会在空闲的时候把它销毁
function fn() {
  var num = 10
  return function () {}
}
fn()() //首先执行fn，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再执行

/* 作用域练习题 */
//++i和i++都是自身累加1，在和其他的值进行运算的时候是有区别的
//i++:先拿i的值进行运算，运算完成本身再+1
//++i:先本身累加1，然后拿累加完成后的结果去运算
var i = 5
console.log(1 + i++) //6
console.log(i + ++i) //7
console.log(2 + i++ + ++i + ++i + i++) //30
console.log(i) //9

function fn() {
  var i = 10
  return function (n) {
    console.log(n + ++i)
  }
}
var f = fn()
f(10) //21
f(20) //32
fn()(10) //21
fn()(20) //31

function fn(i) {
  return function (n) {
    console.log(n + ++i)
  }
}
var f = fn(13)
f(12) //25
f(14) //28
fn(15)(12) //27
fn(16)(13) //29

/* 思考题：用闭包作用域的方式实现选项卡循环绑定事件的处理 */
```

```js
var a = 0
function fun() {
  console.log(a)
  var a = 10
}
fun()
console.log(a)
```

```js
var n = 0
function a() {
  var n = 10
  function b() {
    a++
    console.log(n)
  }
  b()
  return b
}
var c = a()
c()
console.log(n)
```
