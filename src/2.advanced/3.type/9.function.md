---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 九.数据分类[Function]

## 1.调用栈

## 2.递归、尾递归

## 3.arguments、params spread

## 4.作用域、闭包

## 5.var、变量提升

## 6.IIFE、匿名自执行函数

## 7.NFE、函数命名表达式

## 8.箭头函数

## 9.new Function

## 10.setTimeout、setInterval

## 11.call、apply、bind

## 12.部分施用、柯里化

柯里化函数思想：一个 js 预处理的思想-->利用函数执行可以形成一个不销毁的私有作用域的原理，把需要预先处理的内容都存储在这个不销毁的作用域中，并且返回一个小函数，以后我们执行的都是小函数，在小函数宏把之前预先存储的值进行相关的操作

函数柯里化：是指将多变量函数拆解为单变量的多个函数的依次调用，可以从高元函数动态的生成批量的低元的函数。

```js
function add(x, y) {
  return x + y;
}
add(1, 2);
```

柯里化函数 add

```js
function curryAdd(x){
    retrun function(y){
        return x+y
    }
}
add(1)(2)
```

```js
//-->柯里化函数思想：一个js预处理的思想-->利用函数执行可以形成一个不销毁的私有作用域的原理，把需要预先处理的内容都存储在这个不销毁的作用域中，并且返回一个小函数，以后我们执行的都是小函数，在小函数宏把之前预先存储的值进行相关的操作

function _bind(callback, context) {
  context = contenx || window;
  return function () {
    callback.call(context);
  };
}
var obj = { name: "珠峰培训" };
function fn() {
  console.log(this);
}
setTimeout(_bind(fn, obj), 0);
setTimeout(fn.bind(obj), 0);

//给元素的某一个行为绑定方法，当行为触发的时候，执行的对应的方法，此时方法中的this是当前元素本身，而且了浏览器还会给当前的方法默认的传递一个参数值，MouseEvent(鼠标事件对象)
document.body.onclick = function () {
  console.log(this);
};
document.body.onclick = function (num1, num2) {
  console.log(this, num1, num2); //body,MouseEvent，undefined
};
document.body.onclick = function () {
  console.log(this);
}.bind(obj, 100, 200);
//-->除了预先处理了this和需要手动传递的参数值以外，把浏览器默认给传递的鼠标事件对象也进行了预先处理了
```
## 13.执行上下文

## 1.作用域

> callback

```js
//-->forEach：用来遍历数组中的每一项
//1、数组中有几项，那么我们传递进去的匿名回调函数就需要执行几次
//2、每一次执行匿名函数的时候，还给其传递了三个参数值:数组中的当前项item，当前项的索引index，原始的数组input
//3、理论上我们的方法是没哟返回值的，仅仅是遍历数组中的每一项，不对原来的数组进行修改，但是我们可以通过数组的索引来修改原来的数组
var ary = [12, 3, 4, 5, 6];
ary.forEach(function () {
  console.log("ok");
});
var res = ary.forEach(function (item, index, input) {
  input[index] = item * 10;
});

//map方法
//1、map的回调函数中支持return返回值，return是啥，相当于
//2、不管是forEach还是map都在ie6、7、8下不兼容
var ary = [12, 3, 4, 67, 8];
var res = ary.map(function (item, index, input) {
  return item * 10;
});
//匿名回调函数的this是window
var obj = { name: 10 };
var ary = [12, 3, 4, 67, 8];
var res = ary.map(
  function (item, index, input) {
    return this;
  }.call(obj)
); //undefined
var res = ary.map(
  function (item, index, input) {
    return this;
  }.bind(obj)
);

//不管是forEach还是map都支持两个参数，第二个参数是匿名函数的this
var res = ary.map(function (item, index, input) {
  return this;
}, obj);
Array.prototype.myForEach = function (callback, context) {};
```

## 2.this

```js
//我们在js中主要研究的都是函数中的this
//js中的this代表的是当前行为执行的主体，js中的context代表的是当前行为执行的环境（区域）
//this是谁和函数在哪定义的和在哪执行的都没有任何关系，如何区分this呢
//1、函数执行，首先看函数名前面是否有"."，有的话，"."前面是谁this就是谁，没有的话this就是windwo
function fn() {
  console.log(this);
}
var obj = { fn: fn };
f(); //this -->window
obj.fn(); //this-->obj

function sum() {
  //this-->windwo
  fn();
}
sum(); //this-->window

var oo = {
  sum: function () {
    //this-->oo
    fn();
  },
};
oo.sum(); //this-->window

//2、自执行函数中的this永远都是window
//3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素
document.getElementById("div").onclick = fn; //fn-->this -->div
document.getElementById("div").onclick = function () {
  //this-->div
  fn(); //this-->window
};

/* 练习题 */
var num = 20;
var obj = {
  num: 30,
  fn: (function (num) {
    this.num *= 3;
    num += 45;
    var num = 45;
    return function () {
      this.num *= 4;
      num += 20;
      console.log(num);
    };
  })(num), //把全局变量num的值20赋值给自执行函数的形参，而不是obj的30，如果想是obj下的30,我们要写成obj.num
};
var fn = obj.fn;

fn(); //-->65
obj.fn(); //-->85
console.log(window.num, obj.num); //-->240,120
//window
!(function () {})();
```

## 全局变量

```js
//在全局作用域中，带var和不带var的关系
//区别：带var的可以进行预解释，所以在赋值的前面执行不会报错；不带var的是不能进行预解释，在前面执行会报错
console.log(num); //-->undefined
var num = 12;

console.log(num2); //VM229:1 Uncaught ReferenceError: num2 is not defined
num2 = 12;

//关系：num2 = 12-->相当于给window增加了一个叫做num2的属性名，属性值是12
//var num = 12 -->首先它相当于给全局作用域增加了一个全局变量num,但是不仅如此，它也相当于给windwo增加了一个属性名num,属性值是12
var num = 12;
console.log(num);

num2 = 12;
console.log(num2);

//私有作用域中出现一个变量不是私有的，则往上级作用域查找，如果上级作用域没有则继续向上查找，一直找到window为止，如果window下也没有
//-->我们是获取值：console.log(total) -->报错了
//-->我们是设置值：total = 100 -->相当于给window增加了一个属性名total，属性值是100
function fn() {
  // console.log(total)
  total = 100;
}
fn();
console.log(total);
//js中如果不进行任何特殊处理的情况下，上面的代码报错，下面的代码都不在执行
```

### 预解释

```js
//基本数据类型：String Number 按值操作

//引用数据类型：Object和Function -->地址操作

//->函数：1、创建一个函数 2、执行一个函数
function sum() {
  var total = null;
  total = 1 + 1;
  console.log(total);
}
//1、当浏览器加载页面的时候首先会提供一个供js代码执行的环境->全局作用域的环境 首先开辟一个新的内存空间，浏览器为其分配一个16进制的地址，我们假设地址为：xxxfff000
//2、把函数体中的js代码当做"字符串"存储到内存空间中
//3、再把这个地址赋值给当前的函数名sum ->sum =xxxfff000
sum; //->后面不加小括号，代表的就是当前函数本身
sum(); //后面加小括号，代表的是执行当前函数
//函数执行的目的：把函数之前存储的那些字符串变成js代码，然后再让js代码从上到下依次执行

//函数执行的步骤：
//1、函数执行的时候，首先会提供一个供函数体中代码执行的环境 ->'私有作用域'
//2、把函数体重的代码字符从上到下执行

//我们把函数执行的时候形成的这种保护机制叫做闭包

//return 函数的一个出口返回的是其值

//arguments

//实名函数：起了名字的函数就是实名函数
//匿名函数：没有起名字的函数就是匿名函数

//js中常用到的匿名函数有两种
//1、只执行函数：定义函数和函数执行一起完成了
//+ - ! ~ ; ()
//2、函数表达式：把函数定义的部分当做一个值赋值给一个变量或者元素的某一个行为
//oDiv.onclick=function(){}

//函数在整个js中是最复杂也是最重要的知识
/* 
1、一个函数存在了多面性：
普通函数：它本身就是一个普通的函数，执行的时候形成私有的作用域（闭包）形参赋值，预解释，代码执行，执行完成后栈内存销毁/不销毁
类：它有自己的实列，也有一个叫做prototype属性是自己的原型，他的实列都可以指向自己的原型
普通对象：和var obj = {}中的obj一样，就是一个普通的对象，它作为对象可以有一些自己的私有属性，也可以通过__proto__找到Function.prototype
这三者之间没有必然的关系
*/
function Fn() {
  this.x = 100;
}
Fn.prototype.getX = function () {
  console.log(this.x);
};
Fn.aaa = 1000;
var f = new Fn();
f.num-- > undefined;
f.aaa-- > undefined;
var res = Fn();
res-- > undefined;
Fn.aaa-- > 1000;
```

```js
/* js中的数据类型 */
//1、基本数据类型：number、strting、boolean、null、undefined
//2、引用数据类型：object：{}、[]、/^$/、Date   function
var num = 12;
var obj = { name: "珠峰培训", age: 7 };
function fn() {
  console.log("......");
}
console.log(fn); //-->把整个函数的定义部分（函数本身）在控制台输出
console.log(fn()); //-->把当前函数执行的返回结果（return后面写的是啥，返回值就是啥），如果没有return,默认返回值就是undefined

//1、当浏览器加载HTML页面的时候，首先会提供一个供全局JS代码执行的环境 -->全局作用域（global/window）

//2、预解释（变量提升）
// 在当前的作用域中，js代码执行之前，浏览器首先会默认的把所有带var 和function的进行提前的声明或者定义
//1)理解声明和定义
//var num = 12
//声明（declare）：var num -->告诉浏览器在全局作用域中有一个num的变量了-->如果一个变量只是声明但是没有赋值，undefined
//定义（defined）：num = 12 -->给我们的变量进行赋值

//2）对于带var 和 function 关键字的在预解释的时候操作还是不一样的
//var -->在预解释的时候只是提前声明
//function -->在预解释的时候提前的声明+定义都完成了

//3)预解释只发生在当前作用域下，例如：开始只对window下的进行预解释，只有函数执行的时候才会对函数中的进行预解释
var num = 12;
var obj = { name: "珠峰培训", age: 7 };
function fn(num1, num2) {
  var total = num1 + num2;
  console.log(total);
}
console.log(fn);
console.log(fn());

//3、js中内存的分类
//栈内存：用来提供一个供js代码执行的环境 -->作用域（全局作用域/私有的作用域）
//堆内存：用来存储引用数据类型的值 -->对象存储的是属性名和属性值，函数存储的是代码字符串
console.log(num); //undefined
var num = 12;
var obj = { name: "珠峰培训", age: 7 };
fn(100, 200); //可以执行，因为声明和定义都完成了
function fn(num1, num2) {
  var total = num1 + num2;
  console.log(total);
}
console.log(fn);
console.log(fn());

/* 预解释是一种毫无节操的机制 */
//in：""num" in window 判断num是否为window这个对象的是一个属性，是的话返回true
//1、预解释的时候不管你的条件是否成立，都要把带var 的进行提前声明
// window的预解释：var num -->window.num
if (!("num" in windwo)) {
  var num = 12;
}
console.log(num); //undefined

//2、预解释的时候只预解释“=”左边的，右边的是值，不参与预解释
fn(); //-->ok
function fn() {
  console.log("ok");
}
fn(); //ok

//匿名函数之函数表达式：把函数定义的部分当做一个值赋值给我们的变量/元素的某一个事件
fn(); //-->fn is not a function
var fn = (function () {
  console.log("ok");
})(
  // 3、执行函数定义的那个function在全局作用域下不进行预解释，当代码执行到这个位置的时候定义和执行一起完成了
  // 自执行函数：定义和执行一起完成了
  function (num) {}
)(100);
~(function (num) {})(100) + (function (num) {})(100);
-(function (num) {})(100);
!(function (num) {})(100);

//4、函数体中return下面的代码虽然不再执行，但是需要进行预解释;return后面跟着的都是我们返回的值，所以不进行预解释
function fn() {
  // 预解释:var num
  console.log(num); //-->undefined
  return function () {};
  var num = 100;
}
fn();

// 5、在预解释的时候，如果名字已经声明过了，不需要重写再声明，但是需要重写的赋值
//在js中如果变量的名字和函数的名字重复了，也算冲突
//预解释：var fn；window。fn；fn=xxxfff000；window.fn = xxxfff000

var fn = 13;
function fn() {
  console.log("ok");
}

//window预解释
//声明+定义 fn = xxxfff111
//声明 var fn；（不需要重新声明）
//声明（不重复进行）+定义 fn = xxxfff222
fn(); //-->2
function fn() {
  console.log(1);
}
fn(); //-->2
var fn = 10; //fn = 10
fn(); //10() -->fn is not a function
function fn() {
  console.log(2);
}
fn();
```

#### 作用域链

## 1.如何区分私有变量和全局变量

- 在全局作用域下声明（预解释的时候）的变量是全局变量
- 在 私有作用域中声明的变量 和 函数的形参 都是私有的变量
  - 在私有作用域中，我们代码执行的时候遇到了一个变量，首先我们需要确定它是否为私有的变量，如果是私有变量，那么和外面的没有任何的关系；如果不是私有的，则网当前作用域的上级作用域进行查到，如果上级作用域也没有则继续查找，一直找到 window 为止...(作用域链)

## 2.函数执行

- 形成一个新的私有的作用域
- 如果有形参，先给形参赋值
- 进行私有作用域中的预解释
- 私有作用域中的代码从上往下执行
- 函数形成了一个新的私有的作用域保护了里面的私有变量不受外界的干扰（外面修改不了私有的，私有的也修改不了外面的）-->闭包

- 首选代码从上往下预解释声明 total，然后从上往下执行代码，total 此时没有被赋值所有为 undefined

```js
console.log(total); //-->undefined
var total = 0;
```

- 同理私有作用域下面也是，声明了 total 但是没有赋值，结果为 undefiend

```js
var total = 0;
function fn(num1, num2) {
  console.log(total); //undefined
  var total = num1 + num2;
  console.log(total); //-->300
}
fn(100, 200);
console.log(total); //-->0
```

- 私有作用域下面没有 total，顺着作用域链向上查找，找到全局的 total=0

```js
console.log(total); //-->undefined
var total = 0;
function fn(num1, num2) {
  console.log(total); //total 不是私有的找全局下的 total 找这里出现的所有的 total 其实应该是全局的-->0
  total = num1 + num2;
  console.log(total); //-->300
}
fn(100, 200);
console.log(total); //-->300
```

[面试题](./面试题.js)

## 3.如何查找上级作用域

- 看当前函数是在哪个作用域下定义的，那么他的上级作用域就是谁，和函数在哪执行的没有任何关系

```js
var num = 12;
function fn() {
  var num = 120;
  return function () {
    console.log(num);
  };
}
var f = fn();
f();
~(function () {
  var num = 1200;
  f();
})();
```

```js
/* 关于内存的释放和作用域销毁的研究 */
//堆内存
//对象数据类型或者函数数据类型在定义的时候首先会开辟一个堆内存，堆内存有一个引用的弟子，如果外面有变量等知道了这个地址，我们就说这个内存被占用了就不能销毁了
var obj1 = { name: "张三" };
var obj2 = obj1;
//我们想要让堆内存释放/销毁，只需要把所有引用它的变量赋值为null即可，如果当前的堆内存没有任何东西被占用，那么浏览器会在空闲的时候把他销毁...
obj1 = null;
obj2 = null;

//栈内存
// 1）全局作用域
//只有当页面关闭的时候全局作用域才会销毁

// 2）私有作用域（只有函数执行的时候会产生私有作用域）
// 一般情况下，函数执行会形成一个新的私有作用域，当私有作用域中代码执行完成后，我们当前作用域都会主动的进行释放和销毁
//但是还是存在特殊的情况：
// 当前私有作用域中的部分内存被作用域以外的东西占用了，那么当前的这个作用域就不能销毁了
//a、函数执行返回了一个引用数据类型的值，并且在函数的外面被一个其他的东西给接受了，这种情况下一般形成的私有作用域都不会销毁
function fn() {
  var num = 100;
  return function () {};
}
var f = fn();

//在一个私有的作用域中给DOM元素的事件绑定方法，一般情况下我们的私有作用域都不销毁
var oDiv = document.getElementById("div");
~(function () {
  oDiv.onclick = function () {};
})(); //当前的自执行函数形成的这个私有的作用域也不销毁

//下述情况属于不立即销毁，-->fn返回的函数没有被其他的东西占用，但是还需要执行一次，所以暂时不销毁，当返回的值执行完成以后，浏览器会在空闲的时候把它销毁
function fn() {
  var num = 10;
  return function () {};
}
fn()(); //首先执行fn，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再执行

/* 作用域练习题 */
//++i和i++都是自身累加1，在和其他的值进行运算的时候是有区别的
//i++:先拿i的值进行运算，运算完成本身再+1
//++i:先本身累加1，然后拿累加完成后的结果去运算
var i = 5;
console.log(1 + i++); //6
console.log(i + ++i); //7
console.log(2 + i++ + ++i + ++i + i++); //30
console.log(i); //9

function fn() {
  var i = 10;
  return function (n) {
    console.log(n + ++i);
  };
}
var f = fn();
f(10); //21
f(20); //32
fn()(10); //21
fn()(20); //31

function fn(i) {
  return function (n) {
    console.log(n + ++i);
  };
}
var f = fn(13);
f(12); //25
f(14); //28
fn(15)(12); //27
fn(16)(13); //29

/* 思考题：用闭包作用域的方式实现选项卡循环绑定事件的处理 */
```

```js
var a = 0;
function fun() {
  console.log(a);
  var a = 10;
}
fun();
console.log(a);
```

```js
var n = 0;
function a() {
  var n = 10;
  function b() {
    a++;
    console.log(n);
  }
  b();
  return b;
}
var c = a();
c();
console.log(n);
```

## 3.原型和原型链

### 1.原型

每个对象初始化时会生成一个默认的属性，这个属性就是原型，当在这个对象上查找某个属性时，会先在这个对象本身查找这个属性，没有找到就会去原型上查找，原型内部有原型，没有找到依次向内部找属性，这样形成的链状结构我们称为原型链，原型链的顶层是 null

::: tip 函数原型上的一些方法

- apply: function()
- arguments: TypeError: 'arguments', 'callee', and 'caller' cannot be accessed in this context.
- bind: function()
- call: function()
- caller: TypeError: 'arguments', 'callee', and 'caller' cannot be accessed in this context.
- constructor: function()
- length: 0
- name: ""
- toString: function()
- Symbol(Symbol.hasInstance): function()

:::
![](./3.png)

- 1.对象

对象 Object 即是对象也是函数，访问函数的原型(prototype) 得到一个对象 Object.prototype,这个对象的原型(\_\_proto\_\_)可以访问到对象的根 null；访问对象的原型(\_\_proto\_\_)可以得到一个对象 Function.prototype，访问这个对象的原型(\_\_proto\_\_)可以得到 Object.prototype

实例化对象（{}）是一个对象,他的原型(\_\_proto\_\_)指向 Object 函数的 prototype，即 Object.prototype

- 2.函数

函数 Function 即是一个对象也是一个函数，访问函数原型(prototype)得到一个对象 Function.prototype，这个对象的原型(\_\_proto\_\_)指向 Object.prototype;Function 对象的原型(\_\_proto\_\_)指向 Function.prototype

- 3.自定义函数

函数 Function 即是一个对象也是一个函数，访问函数原型(prototype)得到一个对象 Function.prototype，这个对象的原型(\_\_proto\_\_)指向 Object.prototype;Function 对象的原型(\_\_proto\_\_)指向 Function.prototype

### 1.1 apply

- 模拟 apply

```js
Function.prototype.apply = function (context, args) {
  context = context ? Object(context) : window;
  context.fn = this;
  if (!args) {
    return context.fn();
  }
  //利用数组的toString的特性（字符串和数组拼接）
  let r = eval("context.fn(" + args + ")");
  delete context.fn;
  return r;
};
```

```js
fn1.apply("hello", [1, 2, 3, 4]);
```

### 1.2 arguments

函数中参数的传递方式

首先看一道题目

```js
function test(person) {
  person.age = 26;
  person = {
    name: "yyy",
    age: 30,
  };

  return person;
}
const p1 = {
  name: "yck",
  age: 25,
};
const p2 = test(p1);
console.log(p1); // -> ?
console.log(p2); // -> ?
```

#### 对于以上的结果你知道吗？

- 首先，函数传参是传递对象指针的副本
- 然后 p1 的值被修改了
- 但是当我们重新为 person 分配了一个对象时就出现了分歧
  ![](https://zhoubichuan.github.io/Note-Frontend/2.stand/2.W3C/3.JavaScript/%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0.png)
- 这是 person 指针会指向重新赋值的值，所以可以知道 js 中函数赋值操作是共享赋值

### 1.3 bind

- bind 实现原理

- 1.bind 方法可以绑定 this 指向 绑定参数
- 2.bind 方法返回一个绑定后的函数（高阶函数）
- 3.如果绑定的函数被 new 了 当前函数的 this 就是当前的实例
- 4.new 出来的结果可以找到原有类的原型

```js
Function.prototype.bind = function (context) {
  let that = this;
  let bindArgs = Array.prototype.slice.call(arguments, 1);
  function Fn() {}
  function fBound() {
    let args = Array.prototype.slice.call(arguments);
    return that.apply(this instanceof fBound ? this : context, bindArgs);
  }
  Fn.prototype = this.prototype;
  fBound.prototype = new Fn();
  return fBound;
};
fn.prototype.flag = "动物类";
let bindFn = fn.bind(obj, "猫");
let instance = new bindFn(9);
```

### 1.4 call

```js
var obj = { name: "123" };
function fn() {
  console.log(this);
}
fn(); //-->this-->window
fn.call(obj);

Function.prototype.myCall = function (context) {
  //1、将fn中的this变成obj
  eval(this.toString().replace("this", context));
  //2、让fn方法执行
};
fn.myCall(obj);
```
```js
/* 思考题 */
function fn1() {
  console.log(1);
}
function fn2() {
  console.log(2);
}
fn1.call(fn2); //-->1

fn1.call.call(fn2); //fn1.call 首先通过原型链找到Function.prototype上的call方法，然后再让call方法通过原型找到Function原型上的call（因为call本身的值也是一个函数，所以可以找到Function.prototype）,在第二次找到call的时候让方法执行，方法中的this

fn.call(); //-->window 严格模式下window
fn.call(null); //-->window 严格模式下null
fn.call(undefined); //-->window 严格模式下undefined

//apply和call方法的作用是一模一样的，都是用来改变方法的this关键字并且把方法执行：而且在严格模式下和非严格模式下对于第一个参数是null/underfined这种情况的规律也是一样的
fn.call(obj, 100, 200);
fn.apply(obj, [100, 200]); //-->call在给fn传递参数的时候，是一个个的传递值得，而apply不是一个个传，而是把要给fn传递的参数统一的放在一个数组中进行操作--》但是也相当于一个个的给fn形参赋值

//bind:这个方法在ie6-8下不兼容-->和call/apply类似都是用来改变this关键字的

//预处理：事先把fn的this改变为我们想要的结果，并且把对应的参数值也准备好，以后要用到了，直接的执行即可
fn.call(obj, 1, 2); //改变this和执行fn函数是一起都完成了
var tempFn = fn.bind(obj, 1, 2); //只是改变了fn中的this为obj，并且给fn传递了两个参数值1、2，但是此时并没有把fn这个函数执行,执行bind会有一个返回值，这个返回值tempFnv就是我们把fn的this改变后的那个结果
tempFn();

/* 获取数组的最大值 */
var ary = [12, 32, 11, 3, 43, 5, 12, 23, 43];
//1
var sum = ary.sort(function (a, b) {
  return a - b;
});
var min = sum[0];
var max = sum[sum.length - 1];
//2
var min = ary[0];
var max = ary[0];
for (var i = 1; i < ary.length; i++) {
  ary[i] < min ? (min = ary[i]) : null;
  ary[i] > max ? (max = ary[i]) : null;
}
//3
var min = eval("Math.min(" + ary.toString() + ")");
var max = eval("Math.max(" + ary.toString() + ")");

//4
var max = Math.max.apply(null, ary);
var min = Math.min.apply(null, ary);
//6-->括号表达式
function fn1() {
  console.log(1);
}
function fn2() {
  console.log(2);
}
(fn1, fn2)()(
  //只有fn2执行了 （x1,x2,x3）括号表达式，一个括号中出现多项内容，中间用“，”隔开，但是我们最后获取到的结果只有最后一项
  fn2,
  obj.fn
)()(
  //执行的是obj.fn，但是执行的时候里面的this变为了window而不是obj
  obj.fn
)(); //this还是obj

/* 获取平均数 */
function avgFn() {
  //将类数组转换为数组
  // var ary = []
  // for(var i = 0;i<arguments.length;i++){
  //   ary[ary.length] = arguments[i]
  // }
  // ary.sort(function(a,b){
  //   return a-b
  // })
  var ary = Array.prototype.slice.call(arguments);
  //或者ary = [].slice.apply(arguments)
}
ary.pop();
ary.unshift();
return (eval(ary.join("+")) / ary.length).toFixed(2);

//2种方法
function avgFn() {
  Array.prototype.sort.call(arguments, function (a, b) {
    return a - b;
  });
  [].shift.call(arguments);
  [].pop.call(arguments);
  return eval([].join.call(arguments, "+") / arguments.length).toFixed(2);
}
```
- 模拟 call

call 的特点：

- 可以改变我们当前函数的 this 指向
- 会让当前函数执行

```js
Function.prototype.call = function (context) {
  context = context ? Object(context) : window;
  context.fn = this;
  let args = [];
  for (let i = 1; i < arguments.length; i++) {
    args.push("arguments[" + i + "]");
  }
  //利用数组的toString的特性（字符串和数组拼接）
  let r = eval("context.fn(" + args + ")");
  delete context.fn;
  return r;
};
```

调用

```js
fn1.call(fn2);
```

多个 call

```js
//多个call会指向window
fn1.call.call.call(fn2);
```

`new`的底层实现

```js
function _new(fn, ...args) {
  let obj = Object.create(fn.prototype);
  fn.call(obj);
  return obj;
}
```

### 1.5 caller

### 1.6 constructor

### 1.7 length

### 1.8 name

### 1.9 toString

### 1.10 Symbol

### 2.原型链

JS 中的继承

JavaScript 常用的八种继承

## 2.继承

### 1.原型链继承

构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。

```js{10}
function Parent() {
  this.parentName = "parent"
}
Parent.prototype.getParentName = function() {
  return this.parentName + 1
}
function Child() {
  this.childName = "child"
}
Child.prototype = new Parent() // 关键部分，需要先将子构造函数的指针指向父构造函数的实例
Child.prototype.getChildName = function() {
  return this.childName + 1
}
var child = new Child()
console.log(child.parentName) //parent
console.log(child.getParentName()) //parent1
```

::: tip 优点

- 简单易实现，父类新增的实例与属性子类都能访问

:::

::: warning 缺点

- 多个实例对引用类型的操作会被篡改
- 无法实现多继承
- 可以在子类中增加实例属性，如果要新增加原型属性和方法需要在 new 父类构造函数后面
- 创建子类实例时，不能向父类构造函数中传递参数

:::

::: tip 场景

- vue 源码中构造子组件

:::

### 2.构造函数继承

```js{9}
function Parent() {
  this.parentName = "parent"
}
Parent.prototype.getParentName = function() {
  return this.parentName + 1
}
function Child() {
  this.childName = "child"
  Parent.call(this)
}
Child.prototype.getChildName = function() {
  return this.childName + 1
}
var child = new Child()
console.log(child.parentName) //parent
console.log(child.getParentName()) //child.getParentName is not a function
```

::: tip 优点

- 可以实现多继承（call 或者 apply 多个父类）
- 解决了子类构造函数向父类构造函数中传递参数

:::
::: warning 缺点

- 只能继承父类的实例属性，不能继承原型属性
- 无法实现复用，每个子类都有父类构造函数的副本，影响性能

:::

### 3.组合继承

```js
function Parent() {
  this.parentName = "parent";
}
Parent.prototype.getParentName = function () {
  return this.parentName + 1;
};
function Child() {
  this.childName = "child";
  Parent.call(this);
}
Child.prototype = new Parent();
Child.prototype.getChildName = function () {
  return this.childName + 1;
};
var child = new Child();
Child.prototype.constructor = Child;
console.log(child.parentName); //parent
console.log(child.getParentName()); //parent1
```

::: tip 优点

- 可以继承父类原型上的属性，可以传参，可复用
- 每个新实例引入的构造函数属性是私有的

:::
::: warning 缺点

- 调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数

:::

### 4.原型式继承

```js
function Parent() {
  this.parentName = "parent";
}
Parent.prototype.getParentName = function () {
  return this.parentName + 1;
};
function object(obj) {
  function F() {}
  F.prototype = obj;
  return new F();
}
var Child = object(new Parent());
Child.childName = "child";
Child.getChildName = function () {
  return this.childName + 1;
};
var child = Child;
console.log(child.parentName); //parent
console.log(child.getParentName()); //parent1
```

- 缺点：原型链继承多个实列的引用类型属性执行相同，存在篡改的可能。

### 5.寄生式继承

在原型式继承的基础上，增强对象，返回构造函数

```js
function createAnother(original) {
  var clone = Object(original);
  clone.childName = "child";
  clone.getChildName = function () {
    return this.childName + 1;
  };
  return clone; // 返回这个对象
}
function Parent() {
  this.parentName = "parent";
}
Parent.prototype.getParentName = function () {
  return this.parentName + 1;
};
var Child = createAnother(new Parent());
var child = Child;
console.log(child.parentName); //parent
console.log(child.getParentName()); //parent1
```

### 6.寄生组合式继承

```js
function inheritPrototype(c, p) {
  var prototype = Object.create(p.prototype);
  prototype.constructor = c;
  c.prototype = prototype;
}
function Parent() {
  this.parentName = "parent";
}
Parent.prototype.getParentName = function () {
  return this.parentName + 1;
};
function Child() {
  this.childName = "child";
  Parent.call(this);
}
// 将父类原型指向子类
inheritPrototype(Child, Parent);
Child.prototype.getChildName = function () {
  return this.childName + 1;
};
var child = new Child();
console.log(child.parentName); //parent
console.log(child.getParentName()); //parent1
```

### 7.混入方式继承

```js
function Parent() {
  this.parentName = "parent";
}
Parent.prototype.getParentName = function () {
  return this.parentName + 1;
};

function Child() {
  this.childName = "child";
}
Child.prototype.getChildName = function () {
  return this.childName + 1;
};
function MyClass() {
  Parent.call(this);
  Child.call(this);
}
MyClass.prototype = Object.create(Parent.prototype);
Object.assign(MyClass.prototype, Child.prototype);
MyClass.prototype.contructor = MyClass;
var child = new MyClass();
console.log(child.parentName); //parent
console.log(child.getParentName()); //parent1
```

### 8.ES6 类继承 extends

```js
class Parent {
  constructor() {
    this.parentName = "parent";
  }
  getParentName() {
    return this.parentName + 1;
  }
}
class Child extends Parent {
  constructor() {
    super();
    this.childName = "child";
  }
  getChildName() {
    return this.childName + 1;
  }
}
var child = new Child();
console.log(child.parentName); //parent
console.log(child.getParentName()); //parent1
```
