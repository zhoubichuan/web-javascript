---
title: 你真的了解es6的let吗
copyright: true
#permalink: 1
top: 0
date: 2016-06-01 18:46:41
categories:
  
  - 2.标准
  - ECMA
  - ES6
  - 01.你真的了解es6的let吗
#tags:
  - ES6
  - let
  - const
---

![](http://pplgarg0j.bkt.clouddn.com/es6-1-let%E5%92%8Cconst1.jpg)

### 1.首先看一个问题

```
for (var i = 0; i < 3; i++) {
  console.log(i);
}
console.log(i)
console.log(window.i)
```

在浏览器上的结果：

```
0
1
2
3
3 //最后一个3是window.i
```

var 不支持封闭作用域，如果不是在函数里声明的变量会声明到全局作用域（window）上,所以代码块中的变量外部也可以访问，而且还放到全局作用域上面；这样是有问题的

### 2.如果不想声明到全局上可以写一个自执行函数将 i 包在里面

```
(function() {
  for (var i = 0; i < 3; i++) {
    console.log(i);
  }
})();
console.log(i);
console.log(window.i);
```

在浏览器上查看结果：

```
0
1
2
Uncaught ReferenceError: i is not defined
    at <anonymous>:6:13
```

这是 i 也拿不到，因为已经封闭到自执行函数里面了

### 3.异步的情况

```
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
}
```

结果：

```
3
3
3
```

由于代码块中的代码是异步的，会被放到异步队列中执行，当代码把任务队列中的同步代码执行完毕后 i 赋值为 3，然后执行异步队列中的代码，拿到的 i 是 3

### 4.解决异步的问题

```
for (var i = 0; i < 3; i++) {
  (function(i){
    setTimeout(function() {
        console.log(i);
      }, 1000);
  })(i)
}
```

结果：

```
0
1
2
```

- es6 中提供新的 let 和 const 替代 var

### 5.使用块级作用域 let

在用 var 定义变量的时候，变量是通过闭包进行隔离的，现在使用了 let，不仅仅可以通过闭包隔离，还增加了一些块级作用域隔离。块级作用域用一组大括号定义一个块，使用 let 定义的变量在大括号外面是访问不到的代码：

```
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
}
console.log(i)
```

结果：

```
Uncaught ReferenceError: i is not defined
    at <anonymous>:7:13
(anonymous) @ VM1874:7
0
1
2
```

先执行同步代码，i 报错，然后执行异步代码，由于是块级作用域，let i=0 会保存在{}中

let 支持块级作用域声明的变量只会声明在当前的作用域内

let 可以解决作用域污染的问题 和局部作用域的问题

## 在同一个作用域下可以多次声明同一个变量(let 不能重复声明)

代码：

```
var a =1
function b(){
  var a=2
  var a =4
}
b()
```

在浏览器上正常运行

代码：

```
var a =1
function b(){
  let a=2
  let a =4
}
b()
```

在浏览器上运行会报错：提示 a 已经被声明过了

在不同的作用域声明同一个变量是可以的

```
let a =1
function b(){
  let a=2
}
b()
```

如果用 let 声明过了 就不要再 用 var 了

```
function b(){
  let a=2
  var a =4
}
b()
```

在浏览器中运行会报错

## 预解释问题，变量提升(let 不存在这个问题，用 let 解决这个问题)

```
console.log(a)
var a =1;
console.log(a)
```

结果：

```
undefiend
1
```

### 暂存死区

如果作用域内有这样一个变量，这个作用域内就会绑定这个变量，不会继续向上查找

```
let a=1;
{
  console.log(a);
  let a =2;
}
```

浏览器中运行：

```
 a is not defined
```

console.log(a)首先会在{}这个作用域中查找 a 变量，因为 a 在这个作用域中已经声明过，但是 let 没有变量提升，所有会报错

同样

```
let a=1;
{
  console.log(a);
  a =2;
}
```

浏览器中会作用域上面查找

```
1
```

## const 和 let 基本一致

const 声明的变量不能修改，不能被修改引用空间

```
const a =1
a=2
```

这样会报错

```
const a ={age:12}
a.age=5
```

这样是 ok 的
