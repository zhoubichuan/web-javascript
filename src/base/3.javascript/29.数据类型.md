---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 二十九.数据类型

- JavaScript 的基本数据类型
  - 基本数据类型：Number、String、Boolean、Undefined、Null
  - object 是 JavaScript 中所有对象的父对象
  - 数据封装类对象：object、Array、Boolean、Number 和 String
  - 其他对象：Function、Arguments、Math、Data、Error 和 RegExp
  - 其他数据类型：Symbol

## 1.object

## 2.Array

- 学习数组中常用的方法，我们需要按照四个维度去探讨

  - 1）方法的作用
  - 2）需要传那些参数
  - 3）是否有返回值，返回值时什么
  - 4）通过此方法是否对原来的数组产生了改变

### map

遍历数组，返回回调返回值组成的新数组
//map 和 forEach 的语法是一样的，但是比 forEach 多加了一个把原来数组替换的功能

//->原来的数组不变，返回的新数组会变

```js
var newArry = ary.map(function(item) {
return item \* 10;
});
```

### forEach

无法 break,可以用 try/catch 中 throw new Error 来停止

forEach / map 都是用来变量数组中的每一项的

//forEach：数组中有几项函数就执行几次，原来的数组不变

```js
ary.forEach(function(item, index) {
  console.log(item, index)
})
```

### filter

过滤

### some

有一项返回 true，则整体为 true

### every

有一项返回 false，则整体为 false

### join

通过制定连接符生成字符串

### push

- -> 向数组的末尾增加新的内容
- -> 参数：想向末尾增加那些内容就传递谁，而且可以传递多个值，统一向末尾增加多项
- -> 返回:新增加后数组的长度
- -> 原来的数据已经发生了改变

```js
var pushAry = [12, 23, 34]
var pushRes = pushAry.push(100)
console.log("push", pushAry, pushRes)
```

::: tip 扩展
不想使用 push,也想向数组的末尾增加内容

```js
ary[ary.length] = 10
```

:::

### pop

- 删除数组最后一项的内容
  - 参数：没有
  - 返回:被删除的那一项内容
  - 原有的数组也发生了改变

```js
var res = ary.pop()
console.log(res, ary)
```

::: tip 扩展
不用 pop 想删除最后一项的内容

```js
ary.length--
ary.length -= 1
ary.length = ary.length - 1
```

:::

### unshift

向数组的开头增加一项

```js
var res = ary.unshift(100)
console.log(res, ary)
```

### shift

删除数组中的第一项

```js
var res = ary.shift()
console.log(res, ary)
```

- sort(fn)/reverse
  排序与反转，改变原数组

### concat

连接数组，不影响原数组，浅拷贝,把两个数组拼接到一起，原来的数组不变

```js
ary1.concat(ary2) // 把 ary2 和 ary1 拼接 ary2 在后面
ary1.concat() // 把 ary1 克隆一份一模一样的数组
```

newArry = ary.concat(ary2);

### slice(start,end)

关于数组的截取和拼接

实现数组的截取，在原来的数组中截取某一部分

```js
slice(n, m) // 从索引 n 开始，找到索引为 m 出(不包含 m)，将找到的部分已一个新的数组返回，原来的数组不变
slice(n) // 从索引 n 开始一直找到数组的末尾
slice(0) // 克隆一份一模一样的数组原来的数组不变
slice(-n)
slice(n, -m)
slice(n, m) // n 大于 m
slice(-n, -m)
slice(n, m) // n 大于 arr.length
slice(n, m) // m 大于 arr.length
```

### splice(start,number,value...)

返回删除元素组成的数组，value 为插入项，改变原数组

它既能实现删除，也能实现增加，还能实现修改

```js
var ary = [1, 3, 6, 8]
//删除
ary.splice(n, m) //从索引 n 开始，删除 m 个元素，把删除的内容以一个新的数组的方式返回，原来的数组改变
var res = ary.splice(1, 3)
console.log(res, ary)
ary, splice(n) //从索引 n 开始，删除到数组的末尾
ary.splice(0) //把原来的数组中的每一项都删除，把之前的删除的每一项的值以一个新的数组返回（把之前的数组克隆了一份，并且清空了原来的数组）
ary.splice() //返回空数组
ary.splice(ary.length - 1, 0)
//修改
splice(n, m, x) //从索引 n 开始，删除 m 个，用 x 替代删除的部分
var res = ary.splice(2, 4, 1000)
//增加
splice(n, 0, x) // 从索引 n 开始，一个都不删除，把 x 增加到 n 的前面，原来的数组改变
splice(ary.length, 0, x)
```

- indexOf/lastIndexOf(value,fromIndex)
  查找数组项，返回对应的下标
- reduce/reduceRight(fn(pre,cur),defaultPrev)
  两两执行，prev 为上次化简函数的 return 值，cur 为当前值（从第二项开始）

### reverse

把数组倒过来排列原数组也改变

```js
var ary = [2, 4, 523, 6, 7, 766, 23, 34]
var res = ary.reverse()
console.log(res, ary)
```

### sort

给数组进行排序，原有的数组会改变

```js
var ary = [2, 4, 523, 6, 7, 766, 23, 34]
//->ary.sort()这样的话只能处理 10 以内的数组，因为他是安装 unicode 编码的值排列的
var res = ary.sort(function(a, b) {
  return a - b
})
//这样写由小到大排序由大到小 b-a
```

### toString

把数组转换为字符串

```js
//->toString()加参数没有作用
var ary = [1, 3, 5]
var res = ary.toString()
console.log(ary, res)
```

### join

按照每一个分隔符，把数组中的每一个项拼接成一个字符串，原来的数组不变

```js
var res = ary.join("+")
console.log(res) //“1+3+5”
//-->扩展：eval->js 中把字符串变为 js 表达式执行的一个方法
eval(ary.join("+"))
```

::: tip 提示
更多的数组方法
```js
console.dir(Array.prototype)
```
:::

## 3.Boolean

## 4.Number

## 5.String

## 6.检测数据类型的方法

### 1.typeof

- 用来检测数据类型的运算符

```js
console.log(typeof "小明") //'string'
```

- 使用 typeof 检测数据类型，返回的都是一个包含了对应数据类型的字符串，"number"、"string"、"boolean"、"undefined"、"function"、"object"

```js
console.log(typeof typeof typeof function() {}) //"string"
```

- typeof 的局限性
  - typeof null -->'object'
  - 不能具体的细分是数组还是正则或对象等其他的值，因为 typeof 检测数据类型，对于对象数据类型的值，最后返回的都是"object"
- typeof 的应用
  - 函数中赋给参数默认值
  ```js
  function fn(num1, num2) {
    if (typeof num2 === undefined) {
      num2 = 0
    }
  }
  ```
  - 回调函数中
  ```js
  function fn(callback) {
    typeof callback === "function" ? callback() : null
  }
  ```

### 2.instanceof

- 检测某一个实列是否属于某个类

```js
var obj = [12, 2, 3]
console.log(obj instanceof Array) //true
console.log(obj instanceof RegExp) //false
```

- 局限性
  - 不能用来检测和处理字面量方式创建出来的基本数据类型
  ```js
  console.log(1 instanceof Number) //false
  console.log("" instanceof String) //false
  ```
  - 对于基本数据类型来说，字面量方式创建出来的结果和实列方式创建出来的结果是有一定区别的，从严格意义上讲，只有实列创建出来的结果才是标准的对象数据类型，也是标准的 Number 这个类的一个实列，对于字面量方式创建出来的结果是基本的数据类型，不是严格的实列，但是由于 js 的松散特点，导致了可以使用 Numnber.portotype 上提供的方法
  ```js
  console.log(new Number(1) instanceof Number) //true
  ```
- instanceof 的特性：只要在当前实列的原型链上，我们用其检测都会有

```js
var ary = []
console.log(ary instanceof Array) //true
console.log(ary instanceof Object) //true
function fn() {}
console.log(fn instanceof Object) //true
```

### 3.constructor

- 找到其构造函数,作用和 instanceof 非常的相似

```js
var obj = []
console.log(obj.constructor === Array) //true
console.log(obj.constructor === RegExp) //false
console.log(new Number(1).constructor === Number) //true
```

- constructor 检测 Object 和 instanceof 不一样，一般情况下是检测不了的

```js
var reg = /^$/
console.log(reg.constructor === RegExp) //true
console.log(reg.constructor === Object) //false
```

- 局限性:我们可以把类的原型进行重写，在重写的过程中和可能出现把之前的 constructor 覆盖

```js
function fn() {}
fn.prototype = new Array()
var f = new fn()
console.log(f.constructor === Array) //true
```

- 对应特殊的数据类型 null 和 undefined，他们的所属类是 Null 和 Undefined，但是浏览器把这两个类保护起来了,不允许我们在外面访问使用

### 4.toString

- 最准确最常用的方式：首先获取 Object 原型上的 toString 方法，让方法执行，并且改变方法中的 this 关键字的指向,Object.prototype.toString 它的作用是返回当前方法的执行主体（方法中 this）所属的类的详细信息

```js
var obj = { name: "小明" }
console.log(obj.toString()) //"[object Object]"
```

toString 中的 this 是 obj，返回的是 obj 中所属类的信息""[object Object]"第一个 object 代表当前实列是对象数据类型的（这个是固定写死的）第二个 Object 代表的是 obj 所属的类是 Object

```js
Math.toString() //"[object Math]"
```

toString 中的 this 是谁 Math,那么返回的是 Math 所属类的信息

```js
var ary = []
console.log(Object.prototype.toString.call(ary)) //"[object Array]"
console.log(Object.prototype.toString.call([])) //"[object Array]"
console.log(Object.prototype.toString.call("")) //"[object String]"
console.log(Object.prototype.toString.call(1)) //"[object Number]"
console.log(Object.prototype.toString.call(true)) //"[object Boolean]"
console.log(Object.prototype.toString.call(null)) //"[object Null]"
console.log(Object.prototype.toString.call(undefined)) //"[object Math]"
console.log(Object.prototype.toString.call(function fn() {})) //"[object Undefined]"
console.log(Object.prototype.toString.call(new RegExp())) //"[object RegExp]"
```

- 返回的结果是字符串

```js
var reg = /^\[object Array\]\$/
var ary = []
console.log(reg.test(Object.prototype.toString.call(ary))) //false
```

- toString 的理解：乍一看应该是转换为字符串，但是某些 toString 方法不仅仅是转换为字符串，对于 Number、String、Boolean、Array、RegExp、Date、Function 原型上的 toString 方法都是把当前的数据类型转换为字符串的类型(它们的作用仅仅是用来转换为字符串的)

```js
console.log((1).toString()) //"1" Number.prototype.toString-->转换为字符串
console.log((1).__proto__.__proto__.toString()) //["Object","Object"]  Object.prototype.toString
console.log((128).toString(2 / 8 / 10)) //把数字转换为 2/8/10 进制
```
# number 数据类型知识点

## 1.js 中等号的三种情况

### 赋值

```
=
```

### 判断左右两边的值是否相等

```
==
```

### 判断左右两边的值是否觉得相等（包含数据类型）

```
===
```

## 2.number 包含正数、负数、零、小数、NaN

### NaN 不是一个数，但是属于 number 数据类型

```
typeof NaN
//"number"
```

## 3.把其他数据类型转换成 number

### 1.严格转换：Number()

```
Number(true)
//1
```

```
Number(false)
//0
```

```
Number(null)
//0
```

```
Number("")
//0
```

* undefined 是不能转换为有效数字

```
Number(undefined)
//NaN
```

```
Number('12')
//12
```

* 如果是把一个字符串转换为数字，只有字符串中的每一个字符都是有效数字字符，才可以正常转换，相反只要有一个不是有效数字字符(除了空格符)，最后结构就是 NaN

```
Number('12px')
//NaN
```

```
Number('  1 ')
//1
```

### 2.非严格转换

### parseInt/parseFloat 从左到右一次查找，把有效的数字字符转换为数字，但是一旦遇到一个非有效的数字字符，立即停止查找（不管后面是否还有都不再查找了）

```
parseInt('12px')
//12
```

```
parseInt('12px13')
//12
```

```
parseInt('px12')
//NaN
```

```
parseInt('12.5px')
//12.5
```

```
parseFloat('12.5px')
//12.5
```

## 4.数字常用的方法

### toFixed(n):保留小数点后面 n 位

```
var num=3.1415
num.toFixed(2)
//3.14
```

## 5.检测是否为有效数字

### isNaN()用来检测是否为有效数字的方法，如果当前的值是有效数字返回的结果是 false,如果不是有效数字，返回的结果是 true

```
isNaN(12)
//false
```

```
isNaN('qwer')
//true
```

* 如果检测的值不是 number 类型的，浏览器会默认先通过 Number 把它强制转换为 number 类型，然后再检测是否为有效数字

```
isNaN('12')
//false
```
# String 数据类型知识点
//String:字符串类

//js中的对象就是一个泛指，所有东西都是对象，类时把这个泛指具体细分：Object、Array、RegExp、Date、String、Node这些都是js中的内置类，实列是类中的一个具体的东西

var string = "hello";
//一个字符串是由多个字符组成的
//str.length 获取字符串中的个数（字符串长度）
//字符串中也存在索引，也是从0开始的，"w"这个字符的索引就是0
//空格、换行这些特殊的符号也是一个字符

//1、chartAt(索引)获取指定索引位置的字符
// for (var i = 0; i < str.length; i++) {
//   console.log(str.chartAt(i));
// }
//charCodeAt（索引）获取指定索引位置的字符对应的ASCII值
// for (var i = 0; i < str.length; i++) {
//   console.log(str.charCodetAt(i));
// }

//2、字符串的截取
//substr(n,m)，从索引n开始截取m个字符
//substring(n,m)从索引n开发，找到索引m处（不包含m），将找到的字符串返回
//slice（n,m）从索引n开始，找到索引m处（不包含m），将找到的字符串返回 slice支持负数作为索引，str.length+负数索引
//slice（n）没有m代表截取到末尾

//3、字符串中位置查找
//indexOf（字符）获取指定字符在字符串中第一次出现的索引位置
//lastIndexOf（字符）：y获取指定字符在字符串中最后一次出现索引的位置
//如果没有这个字符，返回-1，可以判断字符串中是否包含某个字符

string.indexOf("h");
string.lastIndexOf("h");

//4、大小写转换
//toLowerCase：将所有字符转换为小写
//toUpperCase：将所有字符转换为大写

//5、替换
//replace（要替换的老字符，替换成新字符）
//在不使用正则的情况下每一次调用方法只能替换一次
string.replace("老的", "新的");

string.replace(/老的/g, "新的");

//6、将字符串按照指定的分隔符拆分为数组
//splice
var s = "1+2+3+4+5";
console.log(s.split("+"));
console.log(s.split(""));
console.log(s.split(" "));

//7、match
var time = "2018-02-03 12:03:09";
//2018年02月03日 12时03分09秒

//思路一
function zero(value) {
  return value < 10 ? "0" + value : value;
}
function formatTime(timeStr) {
  var ary = timeStr.split(" ");
  var str1 = ary[0];
  var str2 = ary[1];
  var ary1 = str1.split("-");
  var ary2 = str2.split(":");
  return (
    ary1[0] +
    "年" +
    ary1[1] +
    "月" +
    ary1[2] +
    "日" +
    ary2[0] +
    "时" +
    ary2[1] +
    "分" +
    ary2[2] +
    "秒"
  );
}

console.log(formatTime(time));

//思路二：直接用replace一个个替换（没办法补充0）

//思路三:用正则


对于原始类型来说，直接用 instanceof 来判断类型是不行的，我们可以改造

```js
class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === "string";
  }
}
console.log("hhhh" instanceof PrimitiveString);
```

你可能不知道 Symbol.hasInstance 是什么东西，其实就是一个能
让我们自定义 instanceof 行为的东西，以上代码等同于 typeof 'hhh' === 'string',所以结果自然是 true 了
