---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 三十.模块化

模块化是指把一个复杂的系统分解到多个模块以方便编码。

## 1.1 命名空间

开发网页通过命名空间的方式来组织代码

```js
<script src="jquery.js"></script>
```

- 命名空间冲突，两个库可能使用同一个名称
- 无法合理地管理项目依赖和版本
- 无法方便的控制依赖的加载顺序

## 1.2 CommonJS

`CommonJS`是一种使用广泛的`JavaScript`模块化规范，核心思想是通过`require`方法来同步加载依赖的其他模块，通过 module.exports 导出需要暴露的接口

### 1.2.1 用法

采用 CommonJS 导入导出时的代码如下：

```js
// 导入
const someFun = require("./moduleA")
someFun()

// 导出
module.exports = someFunc
```

### 1.2.2 原理

a.js

```js
let fs = require("fs")
let path = require("path")
let b = req("./b.js")
function req(mod) {
  let filename = path.join(__dirname, mod)
  let content = fs.readFileSync(filename, "utf8")
  let fn = new Function(
    "exports",
    "require",
    "module",
    "__filename",
    "__dirname",
    content + "\n return modules.exports"
  )
  let module = {
    exports: {},
  }
  return fn(module.exports, req, module, __filename, __dirname)
}
```

b.js

```js
console.log("bbb")
exports.name = "zfpx"
```

## 1.3 AMD

AMD 也是一种 JavaScript 模块化规范，与 CommonJS 最大的不同在于它采用异步的方式去加载依赖的模块。AMD 规范主要是为了解决针对浏览器环境的模块化问题，最具代表性的实现是 requirejs。

AMD 的优点

- 可以在不转换代码的情况下直接在浏览器运行
- 可加载多个依赖
- 代码可运行在浏览器或 node.js 环境下

AMD 的缺点

- JavaScript 运行环境没有原生支持 AMD，需要先导入实现了 AMD 的库后才能正常使用。

### 1.3.1 用法

```js
// 定义一个模块
define("a", [], function() {
  return "a"
})
define("b", ["a"], function(a) {
  return a + "b"
})
// 导入和使用
require(["b"], function(b) {
  console.log(b)
})
```

### 1.3.2 原理

```js
let factories = {}
function define(modName, dependencies, factory) {
  factory.dependencies = dependencies
  factories[modName] = factory
}
function require(modNames, callback) {
  let loadedModNames = modNames.map(function(modName) {
    let factory = factories[modName]
    let dependencies = factory.dependencies
    let exports
    require(dependencies, function(...dependencyMods) {
      exports = factory.apply(null, dependencyMods)
    })
    return exports
  })
  callback.apply(null, loadedModNames)
}
```

## 1.4 ES6 模块化

ES6 模块化是 ECMA 提出的 JavaScript 模块化规范，它在语言的层面上实现了模块化。浏览器厂商和 Node.js 都宣布要原生支持该规范。它将逐渐取代 CommonJS 和 AMD`规范，成为浏览器和服务器通用的模块解决方案。 采用 ES6 模块化导入及导出时的代码如下

```js
// 导入
import { name } from "./person.js"
// 导出
export const name = "zfpx"
```

ES6 模块虽然是终极模块化方案，但它的缺点在于目前无法直接运行在大部分 JavaScript 运行环境下，必须通过工具转换成标准的 ES5 后才能正常运行
