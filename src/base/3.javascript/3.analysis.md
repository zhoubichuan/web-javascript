---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 三.变量对象

::: tip 执行上下文

- 当函数运行时，会创建一个执行环境，这个执行环境就叫做执行上下文
- 执行上下文中会创建一个对象叫做变量对象（Value Object），基础数据类型都保存在变量对象中
- 引用数据类型的值保存在堆里，我们通过操作对象的引用地址来操作对象

```js
function task() {
  var a = 1
  var b = {
    name: "abc",
  }
  var c = [1, 2, 3]
}
task()
```

> ```js
> let ExecuteContent = {
>   // 执行上下文中创建的变量对象
>   VO: {
>     a: 1,
>     b: "XO1",
>     c: "XA1",
>   },
> }
> ```
>
> ![](./3.1.png)
> ::: warning 概括一下
> 变量对象是在执行上下文中创建的，可以看成创建对象，执行上下文创建完成后，会推入到执行栈中，可以看成数组中 push 一个对象
> :::

:::


在执行上下文中创建变量对象分为三种情况：

- 全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
- 函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。
- Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。

## 1.全局执行上下文中

- 全局执行上下文中只有一个，在客户端中一般由浏览器创建，也就是我们熟知的 window 对象，我们能通过 this 直接访问到它
- window 对象还是 var 声明的全局变量的载体。我们通过 var 创建的全局对象，都可以通过 window 直接访问

- 1.var 的预解释

var 预解释的时候只提前声明，在代码执行的过程中才定义赋值。

```js
console.log(a)
var a = 1
console.log(a)
// - 代码运行过程
//   - 预解释
//     - a=undefined
//   - 代码执行
//     - console.log(a)
//     - a=1
//     - console.log(a)
```

- 2.function 的预解释

function 预解释的时候，声明和定义都完成了。

```js
var num = 12
function fn() {
  console.log(num)
  var num = 13
  console.log(num)
}
fn()
// - 代码运行过程
//   - 预解释
//     - num=undefined
//     - function fn(){"console.log(num);var num = 13; console.log(num)"}
//   - 代码执行
//     - num =12
//     - 私有作用域下的预解释
//       - num=undefined
//     - 私有作用域下代码执行
//       - console.log(num)//undefined
//       - num=13
//       - console.log(num)//13
```

### 3.预解释的一些情况

- 3.1 不管条件是否成立，都会进行预解释

```js
if (!("a" in window)) {
  var a = 1
}
console.log(a)
// - 预解释
//   - a=undefined//window.a=undefined(全局作用域下定义的)
// - 代码执行
//   - !('a' in window)//false
//   - console.log(a)
//     3.2 只对"="左边的进行预解释，右边的是值，不进行预解释
```

```js
fn()
var fn = function() {
  console.log(1)
}
// - 预解释
//   - fn = undefined
// - 代码执行
//   - fn()//报错
```

- 3.3 window 下对自执行函数是不进行预解释的，自执行函数的定义和执行是一起完成的。但是在执行的过程中，它的私有作用域中是要进行预解释的

```js
;(function(num) {
  console.log(num)
})(100)
// - 预解释
//   - 无
// - 代码执行
//   - console.log(100)
```

- 3.4 函数体中 return 后面的返回值不预解释，但是 return 后面的代码，虽然不执行，但是要预解释

```js
function fn() {
  console.log(num)
  return function() {}
  var num = 12
}
fn()
// - 预解释
//   - function fn(){"console.log(num);return function(){};var num=12"}
// - 代码执行

//   - fn()
//   - 私有作用域下的预解释
//     - function(){""}
//     - num = undefined
//   - 私有作用域下代码的执行

//     - console.log(num)//undefined
//     - num= 12
```

- 3.5 关于重名变量和预解释

```js
function a(x) {}
var a
console.log(a)
// - 预解释
//   - function a(x){""}
// - 代码执行
//   - console.log(a)
```

- 重命名变量 a 又被声明了一次，浏览器在预解释的时候发现已经有一个同名变量 a 了，就不去重复声明了，并且在声明的时候也没有被赋值，则变量 a 还是保持原来的值不变。
- 如果预解释的时候发现重名了，不重新的声明，但是需要重新的定义。（即后面发现是重名的变量，如果该重名变量只是声明没有定义时，可以忽略，但是该重名变量声明并赋值，是需要重新声明的。）

## 2.函数执行上下文中

- 在 JS 执行过程会产生多个执行上下文，JS 引擎会有栈来管理这些执行上下文
- 执行上下文栈也叫做调用栈，执行栈用于存储代码执行期间创建的所有上下文，具有 LIFO（先进后出）的特性
- 栈底永远是全局上下文，栈顶为当前正在执行的上下文
- 当开启一个函数执行时会生成一个新的执行上下文并放入调用栈，执行完毕后自动出栈。

```js
function one() {
  var a = 1
  debugger
  function two() {
    var b = 1
    debugger
    function three() {
      var c = 1
    }
    three()
    debugger
  }
  two()
  debugger
}
one()
```

```js
var globalExecuteContext = {
  VO: {
    setTimeout: "setTimeout",
  },
}
var executeContextStack = [globalExecuteContext]
var oneExecuteContext = {
  VO: { a: 1 },
}
executeContextStack.push(oneExecuteContext)
var towExecuteContext = {
  VO: { b: 2 },
}
executeContextStack.push(twoExecuteContext)
var threeExecuteContext = {
  VO: { c: 3 },
}
executeContextStack.push(threeExecuteContext)
console.log(executeContextStack)
executeContextStack.pop()
executeContextStack.pop()
executeContextStack.pop()
```

## 3.Eval 函数执行上下文中

- 预解释（变量提升），是指在当前作用域下，JS 代码从上到下执行之前，浏览器会默认先把带 var 和 function 关键字的进行提前声明或者定义。
- 声明：只声明，没有定义，如 var num,此时 num 的默认值是 undefined
- 定义：即赋值操作
