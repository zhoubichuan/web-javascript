(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{578:function(t,r,e){"use strict";e.r(r);var a=e(7),n=Object(a.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"四-同步异步编程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四-同步异步编程"}},[t._v("#")]),t._v(" 四.同步异步编程")]),t._v(" "),r("h3",{attrs:{id:"页面渲染原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#页面渲染原理"}},[t._v("#")]),t._v(" 页面渲染原理")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%93.png",alt:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%932.png"}})]),t._v(" "),r("p",[t._v("一个页面展示在用户面前，简单来说，会经历以上5个步骤。我们可以把上面这个图称为"),r("code",[t._v("像素管道")])]),t._v(" "),r("ul",[r("li",[r("p",[t._v("JavaScript：执行js逻辑，修改DOM,修改CSS等。")])]),t._v(" "),r("li",[r("p",[t._v("Style:计算样式。")])]),t._v(" "),r("li",[r("p",[t._v("Layout:在知道对一个元素应用那些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。这个步骤，就是我们常说的重排。")])]),t._v(" "),r("li",[r("p",[t._v("Paint:绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。这个步骤，即使我们常说的重绘。")])]),t._v(" "),r("li",[r("p",[t._v("Composite:渲染层合并，由上一步可知，对页面中DOM元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。")]),t._v(" "),r("p",[t._v("在浏览器器中，页面的渲染由浏览器的渲染进程完成，而渲染进程中，包含了主线程，worker线程，Compositer线程，Raster线程。上述像素管道的5个过程总，前4个过程，都由主线程完成，最后一个步骤，主要有Raster线程、Compositer线程完成。")])])]),t._v(" "),r("h4",{attrs:{id:"javascript、style、layout"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript、style、layout"}},[t._v("#")]),t._v(" JavaScript、Style、Layout")]),t._v(" "),r("p",[t._v("像素管道中的前三个步骤，JavaScript、Style两个步骤如下：")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%932.png",alt:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%932.png"}})]),t._v(" "),r("p",[t._v("接着是Layout,浏览器遍历render tree的每一个节点，计算其确切的位置和大小。最终形成一个Layout Tree.")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%933.png",alt:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%932.png"}})]),t._v(" "),r("h4",{attrs:{id:"paint"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#paint"}},[t._v("#")]),t._v(" Paint")]),t._v(" "),r("p",[t._v("在Paint之前，浏览器会根据Layout Tree，确切需要绘制的对象的层级，我们可以把这个层级叫做"),r("code",[t._v("渲染层")]),t._v("，最终生成Layout Tree。这个阶段被称作："),r("code",[t._v("Update Layer Tree")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%934.png",alt:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%932.png"}})]),t._v(" "),r("p",[t._v("在Paint这个阶段，浏览器会根据"),r("code",[t._v("Layout Tree")]),t._v(",生成Paint Records.")]),t._v(" "),r("p",[t._v("Paint Records 就是描述先画什么，再画什么的记录，跟我们写canvas代码时很像。Paint Records是根据渲染层划分的。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%935.png",alt:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%932.png"}})]),t._v(" "),r("p",[t._v("尽管生成了Paint Records,真正的绘制并不是Paint这个阶段完成的，而是在Composite阶段由Raster线程完成的。")]),t._v(" "),r("h4",{attrs:{id:"composite"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#composite"}},[t._v("#")]),t._v(" Composite")]),t._v(" "),r("p",[t._v("经过之前的几个步骤，浏览器主线程已经将页面的内容分成了若干渲染层。为了提升性能，某些特定的渲染层，会被提升为"),r("code",[t._v("合成层")]),t._v("。我们可以通过下面两个css属性，将某个元素强制提升为合成层：")]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("will-change:transform;\n//或者\ntransform:translateZ(0)\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br")])]),r("p",[t._v("主线程在处理完所有的数据后，会把数据提交到Compositer线程。Compositer线程会利用Raster线程来做光栅处理，并将处理好的内容存入内存中。随着Compositer线程完成渲染层合成操作，扔给GPU,页面最终被渲染到屏幕上。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%936.png",alt:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%932.png"}})]),t._v(" "),r("p",[t._v("可以通过Chrome开发者工具中的Layer来查看合成层。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%937.png",alt:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%932.png"}})]),t._v(" "),r("h4",{attrs:{id:"其他像素管道"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#其他像素管道"}},[t._v("#")]),t._v(" 其他像素管道")]),t._v(" "),r("p",[t._v("上文中的像素管道共有5个步骤。不一定每帧都总是会经过管道每个部分的处理。实际上，不管是使用JavaScript、CSS还是网络动画，在实现视觉变化时，管道针对指定帧的运行还有其他两种方式：")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%938.png",alt:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%932.png"}})]),t._v(" "),r("p",[r("img",{attrs:{src:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%939.png",alt:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/1.render/%E6%B8%B2%E6%9F%932.png"}})]),t._v(" "),r("ul",[r("li",[t._v("第一种就是我们所说的页面没有进行重排，值进行了重绘；")]),t._v(" "),r("li",[t._v("第二种就是页面即没有进行重排，也没有进行重绘")]),t._v(" "),r("li",[t._v("最后的这种运行方式开销最小，适合于页面上的动画效果。")])]),t._v(" "),r("h2",{attrs:{id:"在浏览器地址栏键入url-按下回车之后会经历什么事"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#在浏览器地址栏键入url-按下回车之后会经历什么事"}},[t._v("#")]),t._v(" 在浏览器地址栏键入url,按下回车之后会经历什么事")]),t._v(" "),r("h3",{attrs:{id:"_1-url解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-url解析"}},[t._v("#")]),t._v(" 1.URL解析")]),t._v(" "),r("p",[t._v("一个URL包括"),r("code",[t._v("协议，网络地址，资源路径")])]),t._v(" "),r("p",[t._v("协议：最常用的比如HTTP（超文本传输协议）FTP（文件传输协议）")]),t._v(" "),r("p",[t._v("网络地址：可以是域名或者ip地址，包括端口号，如果没有默认为80端口")]),t._v(" "),r("p",[t._v("如果是不合法的地址，会转给默认的搜索引擎，例如如果你正在使用chrome,可以在url输入框输入你想要的搜索内容，然后搜索引擎会根据关键字进行搜索")]),t._v(" "),r("h3",{attrs:{id:"_2-dns域名解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-dns域名解析"}},[t._v("#")]),t._v(" 2.DNS域名解析")]),t._v(" "),r("h4",{attrs:{id:"_1-先到各种缓存信息中查找"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-先到各种缓存信息中查找"}},[t._v("#")]),t._v(" 1.先到各种缓存信息中查找")]),t._v(" "),r("p",[t._v("先到浏览器缓存记录中查找----浏览器会缓存DNS一段时间")]),t._v(" "),r("p",[t._v("系统缓存----如果浏览器中没有找到，浏览器会有一个系统调用，获得系统缓存中的记录")]),t._v(" "),r("p",[t._v("路由缓存---接着讲请求发给路由器，路由器一般也有自己的DNS缓存")]),t._v(" "),r("h4",{attrs:{id:"_2-dns服务器查找"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-dns服务器查找"}},[t._v("#")]),t._v(" 2.DNS服务器查找")]),t._v(" "),r("p",[t._v("没有则发送请求到本地域名服务器，每一个本地域名服务器都维护一个高速缓存，存放最近用过的域名及其ip地址，如果还没有则发出递归查询（本地服务器请求比他高一级的服务器，如此递归直到根域名服务器，肯定能找到这个服务器的IP地址）通过这个IP可以找到客户端服务器端的唯一路径")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/2.dns/dns.png",alt:""}})]),t._v(" "),r("h3",{attrs:{id:"_3-浏览器主机根据ip地址与服务器建立tcp连接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-浏览器主机根据ip地址与服务器建立tcp连接"}},[t._v("#")]),t._v(" 3.浏览器主机根据ip地址与服务器建立TCP连接")]),t._v(" "),r("p",[t._v("浏览器向服务器端发送SYN连接请求，经过服务器与浏览器三次报文的交互连接建立完成，就可以发送数据了。")]),t._v(" "),r("p",[t._v("找到了正确的IP地址以后就要开始建立连接了，建立连接的过程一般会使用TCP协议，通过三次握手建立连接。")]),t._v(" "),r("h4",{attrs:{id:"tcp三次握手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手"}},[t._v("#")]),t._v(" TCP三次握手")]),t._v(" "),r("p",[t._v("客户端发出建立连接的请求，数据包携带有SYN")]),t._v(" "),r("p",[t._v("如果服务端有开放的端口，可以接受并建立连接，那么服务端会返回SYN+ACK，告诉客户端我可以接受你的请求。")]),t._v(" "),r("p",[t._v("客户端收到服务端的回应，发送ACK给服务端，连接建立。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/2.dns/dns2.png",alt:""}})]),t._v(" "),r("h3",{attrs:{id:"_4-发送http请求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-发送http请求"}},[t._v("#")]),t._v(" 4.发送HTTP请求")]),t._v(" "),r("p",[t._v("与服务器建立了连接后，就可以向服务器发送请求了")]),t._v(" "),r("p",[t._v("根据HTTP协议的要求，组织一个HTTP数据包，向服务器发送HTTP请求，HTTP的请求报头有请求行和请求报头，空行")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/2.dns/dns3.png",alt:""}})]),t._v(" "),r("p",[t._v("在浏览器中查看报文首部")]),t._v(" "),r("p",[t._v("请求行包括请求方法，URI，HTTP版本。首部字段传递重要信息，包括请求首部字段，通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。具体每个首部字段的作用")]),t._v(" "),r("h3",{attrs:{id:"_5-服务器处理请求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-服务器处理请求"}},[t._v("#")]),t._v(" 5.服务器处理请求")]),t._v(" "),r("p",[t._v("服务器收到请求并响应，生成一个HTTP响应报文，通过TCP协议发送给浏览器主机")]),t._v(" "),r("p",[t._v("通过HTTP请求服务器后，服务器会向浏览器返回一个应答信息----HTTP响应。")]),t._v(" "),r("p",[t._v("在HTTP里，有请求就会有响应，哪怕是错误信息，这里我们同样看下响应报文的组成结构。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/2.dns/dns4.png",alt:""}})]),t._v(" "),r("p",[t._v("在响应结果中都会有一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务端的处理是否正常，并能了解具体的错误。")]),t._v(" "),r("p",[t._v("状态码")]),t._v(" "),r("ul",[r("li",[t._v("1xx：信息性状态码")]),t._v(" "),r("li",[t._v("2xx：成功状态码")]),t._v(" "),r("li",[t._v("3xx：重定向状态码")]),t._v(" "),r("li",[t._v("4xx：客户端错误状态码")]),t._v(" "),r("li",[t._v("5xx：服务端错误状态码")])]),t._v(" "),r("h3",{attrs:{id:"_6-端开tcp连接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-端开tcp连接"}},[t._v("#")]),t._v(" 6.端开TCP连接")]),t._v(" "),r("p",[t._v("为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP3次握手类似，关闭TCP连接时需要4次握手。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://zhoubichuan.github.io/Note-Frontend/4.run/1.browser/1.loadingRender/2.dns/dns5.png",alt:""}})]),t._v(" "),r("ul",[r("li",[r("p",[t._v("客户端发起中断请求，发送FIN到服务端")])]),t._v(" "),r("li",[r("p",[t._v("服务端收到请求，可能数据还没有发完，这个时候不会关闭socket,而是回复ACK，告诉客户端知道了")])]),t._v(" "),r("li",[r("p",[t._v("客户端进入Fin_Wait状态，继续等待服务端的FIN报文。服务端发送完毕后，回想客户端发送FIN")])]),t._v(" "),r("li",[r("p",[t._v("客户端收到回复后就回复ACK，并关闭连接")])])]),t._v(" "),r("h3",{attrs:{id:"_7-浏览器解析文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-浏览器解析文件"}},[t._v("#")]),t._v(" 7.浏览器解析文件")]),t._v(" "),r("p",[t._v("浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树总并没有head，dispaly为none等不必显示的节点。")]),t._v(" "),r("p",[t._v("浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加重解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题")]),t._v(" "),r("h3",{attrs:{id:"_8-浏览器布局渲染"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-浏览器布局渲染"}},[t._v("#")]),t._v(" 8.浏览器布局渲染")]),t._v(" "),r("p",[t._v("根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息，HTML默认是流式布局的,CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置，这时就要提到两个重要概念：重排和重绘")]),t._v(" "),r("p",[t._v("我们应该尽量减少重排和重绘，良好的css规范会减少这种操作")]),t._v(" "),r("p",[t._v("最后浏览器绘制各个节点，将页面展示给用户")])])}),[],!1,null,null,null);r.default=n.exports}}]);