(window.webpackJsonp=window.webpackJsonp||[]).push([[209],{616:function(v,_,i){"use strict";i.r(_);var l=i(9),t=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"相关-api-的实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#相关-api-的实现"}},[v._v("#")]),v._v(" 相关 api 的实现")]),v._v(" "),_("p",[v._v("浏览器 API")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("[ ] 1.浏览器提供的符合 W3C 标准的 DOM 操作 API、浏览器差异、兼容性")])]),v._v(" "),_("li",[_("p",[v._v("[ ] 2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局 API、浏览器差异、兼容性")])]),v._v(" "),_("li",[_("p",[v._v("[ ] 3.大量 DOM 操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame 等)")])]),v._v(" "),_("li",[_("p",[v._v("[ ] 4.浏览器海量数据存储、操作性能优化")])]),v._v(" "),_("li",[_("p",[v._v("[ ] 5.DOM 事件流的具体实现机制、不同浏览器的差异、事件代理")])]),v._v(" "),_("li",[_("p",[v._v("[ ] 6.前端发起网络请求的几种方式及其底层实现、可以手写原生 ajax、fetch、可以熟练使用第三方库")])]),v._v(" "),_("li",[_("p",[v._v("[ ] 7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型")])]),v._v(" "),_("li",[_("p",[v._v("[ ]  8.浏览器提供的几种存储机制、优缺点、开发中正确的选择")])]),v._v(" "),_("li",[_("p",[v._v("[ ] 9.浏览器跨标签通信")])]),v._v(" "),_("li",[_("p",[v._v("手动实现一个 instanceof")])]),v._v(" "),_("li",[_("p",[v._v("手动实现一个 new 操作符")])]),v._v(" "),_("li",[_("p",[v._v("class 底层实现原理")])]),v._v(" "),_("li",[_("p",[v._v("[x]  1.手动实现 call、apply、bind")])]),v._v(" "),_("li",[_("p",[v._v("[x] 2.手动实现符合 Promise/A+规范的 Promise、手动实现 async await")])]),v._v(" "),_("li",[_("p",[v._v("[x]  3.手写一个 EventEmitter 实现事件发布、订阅")])]),v._v(" "),_("li",[_("p",[v._v("[ ] 4.可以说出两种实现双向绑定的方案、可以手动实现")])]),v._v(" "),_("li",[_("p",[v._v("[ ] 5.手写 JSON.stringify、JSON.parse")])]),v._v(" "),_("li",[_("p",[v._v("[ ] 6.手写一个模版引擎，并能解释其中原理")])]),v._v(" "),_("li",[_("p",[v._v("[ ]  7.手写懒加载、下拉刷新、上拉加载、预加载等效果")])])])])}),[],!1,null,null,null);_.default=t.exports}}]);